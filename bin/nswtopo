#!/usr/bin/env ruby

# Copyright 2011-2018 Matthew Hollingworth
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

begin
  require 'open3'
  require 'optparse'
  require 'pathname'
  require 'etc'
  require 'yaml'
  require_relative '../lib/nswtopo.rb'

  Thread::report_on_exception = false

  NSWTOPO_VERSION = "2.0.0"
  GDAL_VERSION = begin
    stdout, * = Open3.capture3 "gdal-config", "--version"
    stdout.chomp
  rescue Errno::ENOENT
    abort "error: GDAL not installed"
  end

  case
  when (RUBY_VERSION.split(/\D+/).take(3).map(&:to_i) <=> [2,5]) < 0
    abort "error: ruby 2.5 or greater required"
  when (GDAL_VERSION.split(/\D+/).take(3).map(&:to_i) <=> [2,2]) < 0
    abort "error: GDAL 2.2 or greater required"
  end

  digits = '\d+(?:_\d+)*'
  float  = "[-+]?(?:#{digits}(?=(.)?)(?:\\.(?:#{digits})?)?|\\.#{digits})(?:[eE][-+]?#{digits})?"
  coords = "#{float},#{float}"
  PositiveInt   = /\A#{digits}\z/
  PositiveFloat = /\A#{float}\z/
  PositivePair  = /\A#{float},#{float}\z/
  CoordList     = /\A#{coords}(?:,#{coords})*\z/
  Rotation      = /\A(?:#{float}|magnetic|auto)\z/

  OptionParser.accept PositiveInt, PositiveInt do |string|
    raise OptionParser::InvalidArgument, string unless string.to_i.positive?
    string.to_i
  end
  OptionParser.accept PositiveFloat, PositiveFloat do |string|
    raise OptionParser::InvalidArgument, string unless string.to_f.positive?
    string.to_f
  end
  OptionParser.accept PositivePair, PositivePair do |string|
    raise OptionParser::InvalidArgument, string unless string.split(?,).map(&:to_f).all?(&:positive?)
    string.split(?,).map(&:to_f)
  end
  # TODO NonNegativePair for margins, or get rid of auto-margins for controls?
  OptionParser.accept CoordList, CoordList do |string|
    string.split(?,).map(&:to_f).each_slice(2).to_a
  end
  OptionParser.accept Rotation, Rotation do |string|
    "magnetic" == string ? string : "auto" == string ? string : string.to_f
  end
  OptionParser.accept Pathname do |string|
    raise OptionParser::InvalidArgument, string unless Pathname(string).expand_path.file?
    Pathname(string).expand_path
  end

  config_paths = [ Pathname(__dir__).parent, Pathname(Etc.getpwuid&.dir || Dir.home), Pathname.pwd ].map do |directory|
    directory / ".nswtopo"
  end.select(&:file?)

  # TODO: use \e[1m, \e[m for boldface on/off, use colours, etc.
  # ANSI escape codes:
  # + https://docs.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences)
  # + https://en.wikipedia.org/wiki/ANSI_escape_code
  # TODO: use consistent error message format

  base_parser = OptionParser.new do |parser|
    parser.banner = <<~EOF
      nswtopo - download and create vector topographic maps
      usage: nswtopo [options] [<command> ...]
      commands:
          init         initialise map bounds and scale
          info         display map layers and metadata
          add          add named map layer
          grid         add UTM grid layer
          declination  add magnetic declination layer
          remove       remove map layer
          render       render map in various formats
      command help: nswtopo <command> --help
      options:
    EOF
    parser.on "-c", "--config   <path>", Pathname, "specify additional configuration file" do |path|
      config_paths << path
    end
    parser.on "-v", "--version", "show version information" do
      puts NSWTOPO_VERSION
      exit
    end
    parser.on "-h", "--help", "show this help" do
      puts parser
      exit
    end
  end
  base_parser.order!

  # TODO: rearrange order? e.g. nswtopo map.tgz add [options] <layer>
  command, options = ARGV.shift, Hash.new
  command_parser = OptionParser.new do |parser|
    case command
    when "init"
      options.merge! scale: 25000, rotation: -0.0
      parser.banner = <<~EOF
        nswtopo init - initialise map bounds and scale
        usage: nswtopo init [options] <map.tgz>
        options:
      EOF
      parser.on "-s", "--scale       <scale>",        PositiveInt,  "scale of map (default %i)" % options[:scale]
      parser.on "-b", "--bounds      <bounds.kml>",   Pathname,     "bounds for map as KML or GPX file"
      parser.on "-c", "--coords      <x1,y1,...>",    CoordList,    "bounds for map as one or more WGS84 coordinate pairs" 
      parser.on "-d", "--dimensions  <width,height>", PositivePair, "dimensions of map in mm"
      parser.on "-m", "--margins     <x,y>",          PositivePair, "map margins in mm"
      parser.on "-r", "--rotation    <rotation>",     Rotation,     "map rotation in clockwise degrees, 'auto' or 'magnetic'"
      parser.on "-o", "--overwrite",                                "overwrite existing map file"
      parser.on "-q", "--quiet",                                    "don't report progress"

    when "info"
      parser.banner = <<~EOF
        nswtopo info - display map layers and metadata
        usage: nswtopo info [options] <map.tgz>
        options:
      EOF
      # TODO:
      # parser.on "-e", "--empty", "show empty layers"

    when "add"
      parser.banner = <<~EOF
        nswtopo add - add named map layer
        usage: nswtopo add [options] <map.tgz> <layer>
        options:
      EOF
      parser.on "-r", "--resolution  <resolution>", PositiveFloat, "raster layer resolution in metres"
      parser.on "-p", "--path        <path>",       Pathname,      "source data path for layer"
      parser.on "-a", "--after       <layer>",                     "insert after specified layer"
      parser.on "-b", "--before      <layer>",                     "insert before specified layer"
      parser.on "-o", "--overwrite",                               "overwrite layer if it already exists"
      parser.on "-q", "--quiet",                                   "don't report progress"
    when "grid"
      options.merge! interval: 1000.0
      parser.banner = <<~EOF
        nswtopo grid - add UTM grid layer
        usage: nswtopo grid [options] <map.tgz>
        options:
      EOF
      parser.on "-i", "--interval  <interval>", PositiveFloat, "interval between grid lines in metres (default %i)" % options[:interval]
      parser.on "-p", "--period    <period>",   PositiveInt,   "use periodic grid labeling instead of edge labeling,",
                                                               "with labels every specified number of grid lines"

    when "declination"
      options.merge! spacing: 40.0, offset: 0.0, arrows: 160.0
      parser.banner = <<~EOF
        nswtopo declination - add magnetic declination layer
        usage: nswtopo declination [options] <map.tgz>
        options:
      EOF
      parser.on "-a", "--angle    <angle>",   Float,         "magnetic declination in clockwise degrees", "(calculated automatically by default)"
      parser.on "-i", "--spacing  <spacing>", PositiveFloat, "spacing of declination lines in mm (default %i)" % options[:spacing]
      parser.on "-o", "--offset   <offset>",  Float,         "horizontal offset of declination lines in mm"
      parser.on "-r", "--arrows   <arrows>",  PositiveFloat, "spacing of directional arrows in mm (default %i)" % options[:arrows]

    when "remove"
      parser.banner = <<~EOF
        nswtopo remove - remove map layers
        usage: nswtopo remove [options] <map.tgz> <layer> [<layer> ...]
        options:
      EOF

    when "render"
      options.merge! ppi: 300
      parser.banner = <<~EOF
        nswtopo render - render map in various formats
        usage: nswtopo render [options] <map.tgz> <format_or_path> [<format_or_path> ...]
        formats: #{NSWTopo::FORMATS.join ?\s}
        options:
      EOF
      parser.on "-p", "--ppi        <ppi>", PositiveInt, "resolution for raster formats in pixels per inch (default %i)" % options[:ppi]
      parser.on "-d", "--dither",                        "save raster in indexed colour mode using dithering"
      parser.on "-w", "--worldfile",                     "save corresponding world file for raster formats"
      parser.on "-q", "--quiet",                         "don't report progress"
    # when "layers"  # TODO show available map layers from layers/nsw, layers/act etc?
    # when "reorder" # TODO move layer: --before <layer>, --after <layer> etc

    when nil
      puts base_parser
      raise OptionParser::MissingArgument, "no command specified"

    else
      puts base_parser
      raise OptionParser::InvalidArgument, command
    end

    parser.on "-h", "--help",  "show this help" do
      puts parser
      exit
    end
  end
  command_parser.order! into: options
  # options.transform_keys!(&:to_s)

  $stdout = File.open(File::NULL, "w") if options.delete :quiet
  if ARGV.none?
    puts command_parser
    raise OptionParser::MissingArgument, "no map path specified"
  end
  tgz_path = Pathname(ARGV.shift)

  config = config_paths.map do |path|
    YAML.load path.read
  rescue YAML::Exception
    warn "warning: couldn't parse #{path}, ignoring"
  end.grep(Hash).inject({}, &:deep_merge)

  begin
    in_path = case command
    when "init"
      raise OptionParser::InvalidArgument, "#{tgz_path} already exists" if tgz_path.exist? && !options.delete(:overwrite)
    else
      raise OptionParser::InvalidArgument, "no such file #{tgz_path}" unless tgz_path.exist?
      raise OptionParser::InvalidArgument, "#{tgz_path} is not a file" unless tgz_path.file?
      tgz_path
    end
    arity, error = NSWTopo.method(command).arity, nil

    NSWTopo::Archive.open(tgz_path, *in_path) do |archive|
      args = [ archive, *ARGV, options, config ]
      case
      when arity >= 0 && args.length > arity
        puts command_parser
        raise OptionParser::NeedlessArgument, ARGV.last(args.length - arity).join(?\s)
      when arity >= 0 ? args.length < arity : args.length + arity + 1 < 0
        puts command_parser
        raise OptionParser::MissingArgument, ARGV
      end

      NSWTopo.send command, *args
    rescue NSWTopo::PartialFailureError => error
    end
    raise error.message if error
  end
rescue Interrupt
  abort "\r\033[Knswtopo: interrupted"
rescue RuntimeError => error
  abort "\r\033[Knswtopo: #{error.message}"
end
