#!/usr/bin/env ruby

# Copyright 2011-2019 Matthew Hollingworth
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

begin
  require 'open3'
  require 'optparse'
  require 'pathname'
  require 'etc'
  require 'yaml'
  require_relative '../lib/nswtopo.rb'

  Thread::report_on_exception = false

  NSWTOPO_VERSION = "2.0.0"
  GDAL_VERSION = begin
    stdout, * = Open3.capture3 "gdal-config", "--version"
    stdout.chomp
  rescue Errno::ENOENT
    abort "\e[31mnswtopo:\e[0m GDAL not installed"
  end

  case
  when (RUBY_VERSION.split(/\D+/).take(3).map(&:to_i) <=> [2,5]) < 0
    abort "\e[31mnswtopo:\e[0m ruby 2.5 or greater required"
  when (GDAL_VERSION.split(/\D+/).take(3).map(&:to_i) <=> [2,3]) < 0
    abort "\e[31mnswtopo:\e[0m GDAL 2.3 or greater required"
  end

  digits = '\d+(?:_\d+)*'
  float  = "[-+]?(?:#{digits}(?=(.)?)(?:\\.(?:#{digits})?)?|\\.#{digits})(?:[eE][-+]?#{digits})?"
  coords = "#{float},#{float}"
  PositiveInt   = /\A#{digits}\z/
  PositiveFloat = /\A#{float}\z/
  PositivePair  = /\A#{float},#{float}\z/
  CoordList     = /\A#{coords}(?:,#{coords})*\z/
  Rotation      = /\A(?:#{float}|magnetic|auto)\z/
  States        = Pathname(__dir__).parent.join("layers").children.select(&:directory?).map(&:basename).map(&:to_s)

  OptionParser.accept PositiveInt, PositiveInt do |string|
    raise OptionParser::InvalidArgument, string unless string.to_i.positive?
    string.to_i
  end
  OptionParser.accept PositiveFloat, PositiveFloat do |string|
    raise OptionParser::InvalidArgument, string unless string.to_f.positive?
    string.to_f
  end
  OptionParser.accept PositivePair, PositivePair do |string|
    raise OptionParser::InvalidArgument, string unless string.split(?,).map(&:to_f).all?(&:positive?)
    string.split(?,).map(&:to_f)
  end
  # TODO NonNegativePair for margins, or get rid of auto-margins for controls?
  OptionParser.accept CoordList, CoordList do |string|
    string.split(?,).map(&:to_f).each_slice(2).to_a
  end
  OptionParser.accept Rotation, Rotation do |string|
    "magnetic" == string ? string : "auto" == string ? string : string.to_f
  end
  OptionParser.accept Pathname do |string|
    raise OptionParser::InvalidArgument, string unless Pathname(string).expand_path.file?
    Pathname(string).expand_path
  end

  config_paths = [ Pathname(__dir__).parent, Pathname(Etc.getpwuid&.dir || Dir.home), Pathname.pwd ].map do |directory|
    directory / ".nswtopo"
  end.select(&:file?)

  base_parser = OptionParser.new do |parser|
    parser.banner = <<~EOF
      nswtopo - download and create vector topographic maps
      usage: nswtopo [options] [<command> ...]
      commands:
          init         initialise map bounds and scale
          info         display map layers and metadata
          add          add named map layer
          grid         add UTM grid layer
          declination  add magnetic declination layer
          remove       remove map layer
          render       render map in various formats
          layers       list available map layers
      command help: nswtopo <command> --help
      options:
    EOF
    parser.on "-c", "--config   <path>", Pathname, "specify additional configuration file" do |path|
      config_paths << path
    end
    parser.on "-v", "--version", "show version information" do
      puts NSWTOPO_VERSION
      exit
    end
    parser.on "-h", "--help", "show this help" do
      puts parser
      exit
    end
  end
  base_parser.order!

  # TODO: rearrange order? e.g. nswtopo map.tgz add [options] <layer>
  command, options = ARGV.shift, Hash.new
  command_parser = OptionParser.new do |parser|
    case command
    when "init"
      options.merge! scale: 25000, rotation: 0.0
      parser.banner = <<~EOF
        nswtopo init - initialise map bounds and scale
        usage: nswtopo init [options] <map.tgz>
        options:
      EOF
      parser.on "-s", "--scale       <scale>",        PositiveInt,  "scale of map (default %i)" % options[:scale]
      parser.on "-b", "--bounds      <bounds.kml>",   Pathname,     "bounds for map as KML or GPX file"
      parser.on "-c", "--coords      <x1,y1,...>",    CoordList,    "bounds for map as one or more WGS84 coordinate pairs" 
      parser.on "-d", "--dimensions  <width,height>", PositivePair, "dimensions of map in mm"
      parser.on "-m", "--margins     <x,y>",          PositivePair, "map margins in mm"
      parser.on "-r", "--rotation    <rotation>",     Rotation,     "map rotation in clockwise degrees, 'auto' or 'magnetic'"
      parser.on "-o", "--overwrite",                                "overwrite existing map file"
      parser.on "-q", "--quiet",                                    "don't report progress"

    when "info"
      parser.banner = <<~EOF
        nswtopo info - display map layers and metadata
        usage: nswtopo info [options] <map.tgz>
        options:
      EOF
      parser.on "-e", "--empty", "show empty layers"

    when "add"
      parser.banner = <<~EOF
        nswtopo add - add named map layer
        usage: nswtopo add [options] <map.tgz> <layer> [<layer> ...]
        options:
      EOF
      parser.on "-r", "--resolution  <resolution>", PositiveFloat, "raster layer resolution in metres"
      parser.on "-p", "--path        <path>",       Pathname,      "source data path for layer"
      parser.on "-a", "--after       <layer>",                     "insert after specified layer"
      parser.on "-b", "--before      <layer>",                     "insert before specified layer"
      parser.on "-o", "--overwrite",                               "overwrite layer if it already exists"
      parser.on "-q", "--quiet",                                   "don't report progress"

    when "grid"
      options.merge! interval: 1000.0
      parser.banner = <<~EOF
        nswtopo grid - add UTM grid layer
        usage: nswtopo grid [options] <map.tgz>
        options:
      EOF
      parser.on "-i", "--interval  <interval>", PositiveFloat, "interval between grid lines in metres (default %i)" % options[:interval]
      parser.on "-p", "--period    <period>",   PositiveInt,   "use periodic grid labeling instead of edge labeling,",
                                                               "with labels every specified number of grid lines"

    when "declination"
      options.merge! spacing: 40.0, offset: 0.0, arrows: 160.0
      parser.banner = <<~EOF
        nswtopo declination - add magnetic declination layer
        usage: nswtopo declination [options] <map.tgz>
        options:
      EOF
      parser.on "-a", "--angle    <angle>",   Float,         "magnetic declination in clockwise degrees", "(calculated automatically by default)"
      parser.on "-i", "--spacing  <spacing>", PositiveFloat, "spacing of declination lines in mm (default %i)" % options[:spacing]
      parser.on "-o", "--offset   <offset>",  Float,         "horizontal offset of declination lines in mm"
      parser.on "-r", "--arrows   <arrows>",  PositiveFloat, "spacing of directional arrows in mm (default %i)" % options[:arrows]

    # TODO: rename to "delete"
    when "remove"
      parser.banner = <<~EOF
        nswtopo remove - remove map layers
        usage: nswtopo remove [options] <map.tgz> <layer> [<layer> ...]
        options:
      EOF

    when "render"
      parser.banner = <<~EOF
        nswtopo render - render map in various formats
        usage: nswtopo render [options] <map.tgz> <format_or_path> [<format_or_path> ...]
        formats: #{NSWTopo::Formats.extensions.sort.join ?\s}
        options:
      EOF
      parser.on "-p", "--ppi        <ppi>", PositiveInt, "resolution for raster formats in pixels per inch (default %i)" % NSWTopo::DEFAULT_PPI
      parser.on "-z", "--zoom       <zoom>", Integer,    "maximum zoom level for mbtiles format (default %i)" % NSWTopo::DEFAULT_ZOOM
      parser.on "-d", "--dither",                        "save raster in indexed colour mode with dithering"
      parser.on "-w", "--worldfile",                     "save projection (.prj) and world file (.wld) for raster formats"
      parser.on "-o", "--overwrite",                     "overwrite existing output files"
      parser.on "-f", "--force",                         "force regeneration of cached SVG"
      parser.on "-q", "--quiet",                         "don't report progress"

    when "layers"
      parser.banner = <<~EOF
        nswtopo layers - list available map layers
        usage: nswtopo layers [options]
        options:
      EOF
      parser.on "-s", "--state  <#{States.join ?|}>", States, "only show layers for specified state"

    # when "reorder" # TODO move layer: --before <layer>, --after <layer> etc

    when nil
      raise OptionParser::MissingArgument, "no command specified"

    else
      raise OptionParser::InvalidArgument, command
    end

    parser.on "-h", "--help",  "show this help" do
      puts parser
      exit
    end
  rescue OptionParser::ParseError => error
    warn base_parser
    raise error.message
  end
  command_parser.order! into: options

  if command == "layers"
    raise OptionParser::NeedlessArgument, ARGV if ARGV.any?
    NSWTopo.layers options
    exit
  end

  $stdout = File.open(File::NULL, "w") if options.delete :quiet
  raise OptionParser::MissingArgument, "no map path specified" if ARGV.empty?
  tgz_path = Pathname(ARGV.shift)

  config = config_paths.map do |path|
    YAML.load path.read
  rescue YAML::Exception
    warn "warning: couldn't parse #{path}, ignoring"
  end.grep(Hash).inject({}, &:deep_merge)

  begin
    in_path = case command
    when "init"
      raise "#{tgz_path} already exists" if tgz_path.exist? && !options.delete(:overwrite)
    else
      raise "no such file #{tgz_path}" unless tgz_path.exist?
      raise "#{tgz_path} is not a file" unless tgz_path.file?
      tgz_path
    end
    arity, error = NSWTopo.method(command).arity, nil

    NSWTopo::Archive.open(tgz_path, *in_path) do |archive|
      args = [ archive, config, *ARGV, options ]
      case
      when arity >= 0 && args.length > arity
        raise OptionParser::NeedlessArgument, ARGV.last(args.length - arity).join(?\s)
      when arity >= 0 ? args.length < arity : args.length + arity + 1 < 0
        raise OptionParser::MissingArgument
      end

      NSWTopo.send command, *args
    rescue NSWTopo::PartialFailureError => error
    end
    raise error.message if error
  end
rescue OptionParser::ParseError => error
  warn command_parser
  abort "\r\e[K\e[31mnswtopo:\e[0m #{error.message}"
rescue Interrupt
  abort "\r\e[Knswtopo: interrupted"
rescue RuntimeError => error
  abort "\r\e[K\e[31mnswtopo:\e[0m #{error.message}"
end
