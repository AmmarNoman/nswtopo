#!/usr/bin/env ruby

require 'uri'
require 'json'
require 'ostruct'
require 'optparse'

FORMATS = %w[shp tab gpkg sqlite]
ServerError = Class.new StandardError
EmptyError = Class.new StandardError

def get_json(options, path = nil, query = {})
  query = query.merge(f: "json").map do |key, value|
    "#{key}=#{URI.escape value.to_s}"
  end.join(?&)
  url = [ options.url, path ].compact.join ?/
  json = IO.popen %Q[curl --config -], "r+" do |pipe|
    pipe.puts %Q[--user "#{options.user}"] if options.user
    pipe.puts %Q[--user-agent "Ruby/#{RUBY_VERSION}"]
    pipe.puts %Q[--referer "#{url}"]
    pipe.puts %Q[--silent]
    pipe.puts %Q[--netrc-optional]
    pipe.puts %Q[--compressed]
    pipe.puts %Q[--url "#{url}?#{query}"]
    pipe.close_write
    pipe.read
  end
  raise EmptyError if json.empty? && $?.success?
  JSON.parse json
end

options = OpenStruct.new(format: "shp", fields: ?*, tries: 5)
begin
  opts = OptionParser.new("Scrape data from an ArcGIS REST endpoint.\nUsage: scrape [options] url path") do |opts|
    opts.on "-n", "--name       NAME", /^\w+$/, "name of saved dataset"
    opts.on "-f", "--format     FORMAT", FORMATS, "output file format [#{FORMATS.join ?|}]"
    opts.on "-w", "--where      WHERE", "filtering clause"
    opts.on       "--fields     FIELDS", "comma-separated list of fields"
    opts.on "-p", "--paginate   PAGINATE", Integer, "number of records per request"
    opts.on "-a", "--append",   "append to existing data"
    opts.on "-u", "--user       USER:PASSWORD", "username and password for authentication"
    opts.on "-t", "--tries      TRIES", "number of tries before reducing request size"
    opts.on "-e", "--epsg       EPSG", "EPSG number for data retrieval"
    opts.on "-r", "--reproject  EPSG", "EPSG number for local reprojection"
  end
  opts.order!(into: options) do |arg|
    case
    when !options.url
      options.url = (/^https?:\/\// === arg ? arg : "http://#{arg}").chomp(?/)
      raise OptionParser::InvalidArgument.new(arg) unless /.*\/(MapServer|FeatureServer)\/\d+$/ === options.url
    when !options.path then options.path = arg
    else raise OptionParser::InvalidArgument.new(arg)
    end
  end
  abort opts.to_s unless options.url && options.path
rescue OptionParser::InvalidOption, OptionParser::MissingArgument, OptionParser::InvalidArgument => e
  abort e.message
end

begin
  layer = get_json(options)
  options.name ||= layer["name"].gsub(/[^\w]+/, ?_)
  options.where ||= layer["fields"].find do |field|
    "esriFieldTypeOID" == field["type"]
  end.fetch("name") + " IS NOT NULL"
  options.paginate ||= [ 1000, layer.fetch("maxRecordCount", 1000) ].min
  error, object_ids = get_json(options, "query", returnIdsOnly: true, where: options.where).values_at "error", "objectIds"
  raise ServerError, "%s (%s)" % error.values_at("message", "code") if error
  raise ServerError, "no results returned" unless object_ids
  update = options.append ? "-update -append" : "-update -overwrite"
  format = case options.format
  when "shp"    then %Q[-f "ESRI Shapefile"]
  when "tab"    then %Q[-f "MapInfo File"]
  when "gpkg"   then %Q[-f GPKG]
  when "sqlite" then %Q[-f SQLite]
  end
  reproject = %Q[-t_srs epsg:#{options.reproject}] if options.reproject
  query = options.epsg ? { outFields: options.fields, outSR: options.epsg } : { outFields: options.fields }
  count, total, data = 0, object_ids.length, nil
  progress = "\rretrieving %s: %6.2f%% of #{total} features"
  $stdout << progress % [ options.name, 0.0 ]
  while object_ids.any?
    page, ids = nil, object_ids.take(options.paginate)
    options.tries.times do
      page = begin
        get_json(options, "query", query.merge(objectIds: ids.join(?,)))
      rescue EmptyError
        next
      end
      page.dig("error", "code") == 500 ? page = nil : break
    end
    unless page
      options.paginate > 1 ? options.paginate /= 2 : sleep(10)
      $stderr.puts "\nWARNING: retrying at #{options.paginate} features per request"
      next
    end
    raise ServerError, "%s (%s)" % page["error"].values_at("message", "code") if page["error"]
    page["spatialReference"]["wkid"] = page["spatialReference"]["latestWkid"] if page["spatialReference"]["latestWkid"]
    count += object_ids.shift(options.paginate).length
    if options.format == "shp"
      data ? data["features"] += page["features"] : data = page
    else
      IO.popen %Q[ogr2ogr -skipfailures #{reproject} #{format} -nln #{options.name} #{update} "#{options.path}" /vsistdin/], "w" do |pipe|
        pipe.write page.to_json
      end
      update = "-update -append"
    end
    $stdout << progress % [ options.name, 100.0 * count / total ]
  end
  $stdout.puts
  IO.popen %Q[ogr2ogr -skipfailures #{reproject} #{format} -nln #{options.name} #{update} "#{options.path}" /vsistdin/], "w" do |pipe|
    pipe.write data.to_json
  end unless options.format == "shp"
  exit $?.exitstatus
rescue JSON::ParserError => error
  message =  $?.success? ? "JSON: #{error.message}" : "curl failed with #{options.url}"
  abort "\nERROR: #{message}"
rescue ServerError => error
  abort "\nERROR: #{error.message}"
rescue EmptyError
  abort "\NERROR: empty response"
rescue Interrupt
  abort "\nInterrupted."
end
