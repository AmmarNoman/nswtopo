#!/usr/bin/env ruby

require 'cgi'
require 'json'
require 'ostruct'
require 'optparse'

FORMATS = %w[shp tab gpkg sqlite]
ServerError = Class.new StandardError

def get_json(options, path = nil, query = {})
  query = query.merge(f: "json").map do |key, value|
    "#{key}=#{CGI.escape value.to_s}"
  end.join(?&)
  url = [ options.url, path ].compact.join ?/
  IO.popen %Q[curl --config -], "r+" do |pipe|
    pipe.puts %Q[--user "#{options.user}"] if options.user
    pipe.puts %Q[--user-agent "Ruby/#{RUBY_VERSION}"]
    pipe.puts %Q[--referer "#{url}"]
    pipe.puts %Q[--silent]
    pipe.puts %Q[--fail]
    pipe.puts %Q[--netrc-optional]
    pipe.puts %Q[--compressed]
    pipe.puts %Q[--url "#{url}?#{query}"]
    pipe.close_write
    pipe.read
  end.tap do |json|
    raise ServerError, "curl reports server error" if $?.exitstatus == 22
    raise ServerError, "empty response" if json.empty? && $?.success?
  end
end

def parse_json(*args)
  JSON.parse get_json(*args)
end

options = OpenStruct.new(format: "shp", fields: ?*, tries: 10)
begin
  opts = OptionParser.new("Scrape data from an ArcGIS REST endpoint.\nUsage: scrape [options] url path") do |opts|
    opts.on "-n", "--name       NAME", /^\w+$/, "name of saved dataset"
    opts.on "-f", "--format     FORMAT", FORMATS, "output file format [#{FORMATS.join ?|}]"
    opts.on "-w", "--where      WHERE", "filtering clause"
    opts.on       "--fields     FIELDS", "comma-separated list of fields"
    opts.on "-p", "--paginate   PAGINATE", Integer, "number of records per request"
    opts.on "-u", "--user       USER:PASSWORD", "username and password for authentication"
    opts.on "-t", "--tries      TRIES", Integer, "number of tries before reducing request size"
    opts.on "-e", "--epsg       EPSG", "EPSG number for data retrieval"
    opts.on "-r", "--reproject  EPSG", "EPSG number for local reprojection"
    opts.on "-c", "--concat",   "concatenate paged results before saving"
    opts.on "-q", "--quiet",    "no diagnostic output"
  end
  opts.order!(into: options) do |arg|
    case
    when !options.url
      options.url = (/^https?:\/\// === arg ? arg : "http://#{arg}").chomp(?/)
      raise OptionParser::InvalidArgument.new(arg) unless /.*\/(MapServer|FeatureServer)\/\d+$/ === options.url
    when !options.path then options.path = arg
    else raise OptionParser::InvalidArgument.new(arg)
    end
  end
  abort opts.to_s unless options.url && options.path
rescue OptionParser::InvalidOption, OptionParser::MissingArgument, OptionParser::InvalidArgument => e
  abort e.message
end

begin
  layer = parse_json options
  options.name ||= layer["name"].gsub(/[^\w]+/, ?_)
  options.where ||= layer["fields"].find do |field|
    "esriFieldTypeGeometry" == field["type"]
  end.fetch("name") + " IS NOT NULL"
  options.paginate ||= [ 1000, layer.fetch("maxRecordCount", 1000) ].min
  error, object_ids = parse_json(options, "query", returnIdsOnly: true, where: options.where).values_at "error", "objectIds"
  raise ServerError, "%s (%s)" % error.values_at("message", "code") if error
  raise ServerError, "no results returned" unless object_ids
  format = case options.format
  when "shp"    then %Q[-f "ESRI Shapefile"]
  when "tab"    then %Q[-f "MapInfo File"]
  when "gpkg"   then %Q[-f GPKG]
  when "sqlite" then %Q[-f SQLite -nlt PROMOTE_TO_MULTI]
  end
  update = %Q[-update -overwrite] if File.exists?(options.path)
  create = File.exists?(options.path) ? %Q[-lco SPATIAL_INDEX=YES] : %Q[-dsco SPATIALITE=YES -lco SPATIAL_INDEX=YES] if options.format == "sqlite"
  reproject = %Q[-t_srs epsg:#{options.reproject}] if options.reproject
  query = options.epsg ? { outFields: options.fields, outSR: options.epsg } : { outFields: options.fields }
  count, total, data = 0, object_ids.length, nil
  progress = " retrieving %s: %6.2f%% of #{total} features\r"
  $stdout << progress % [ options.name, 0.0 ] unless options.quiet
  while object_ids.any?
    json, ids = nil, object_ids.take(options.paginate)
    options.tries.times do
      json = begin
        get_json options, "query", query.merge(objectIds: ids.join(?,))
      rescue ServerError
        next
      end
      error = JSON.parse(json)["error"]
      case
      when error && [4, 5].include?(error["code"].to_i % 100) then json = nil
      when error then raise ServerError, "%s (%s)" % error.values_at("message", "code")
      else break
      end
    end
    case
    when !json && options.paginate > 1
      $stdout.puts unless options.quiet
      $stderr.puts "WARNING: retrying #{options.name} at #{options.paginate /= 2} features per request"
      next
    when !json
      raise ServerError, "failed at one feature per request"
    when options.concat
      page = JSON.parse json
      data ? data["features"] += page["features"] : data = page
    else
      IO.popen %Q[ogr2ogr -skipfailures #{reproject} #{format} -nln #{options.name} #{create} #{update} "#{options.path}" /vsistdin/], "w" do |pipe|
        pipe.write json
      end
      exit $?.exitstatus unless $?.success?
      create, update = nil, "-update -append"
    end
    count += object_ids.shift(options.paginate).length
    $stdout << progress % [ options.name, 100.0 * count / total ] unless options.quiet
  end
  $stdout.puts unless options.quiet
  IO.popen %Q[ogr2ogr -skipfailures #{reproject} #{format} -nln #{options.name} #{create} #{update} "#{options.path}" /vsistdin/], "w" do |pipe|
    pipe.write data.to_json
  end if options.concat
  exit $?.exitstatus
rescue JSON::ParserError => error
  message =  $?.success? ? "JSON: #{error.message}" : "curl failed with #{options.url}"
  abort "\nERROR: #{message}"
rescue ServerError => error
  abort "\nERROR: #{error.message}"
rescue Interrupt
  abort "\nInterrupted."
end
