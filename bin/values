#!/usr/bin/env ruby

# dodgy utility for extracting attribute values from various server protocols
require 'uri'
require 'open-uri'
require 'json'
require 'net/http'
require 'uri'
require 'cgi'
require 'pathname'
require 'ostruct'

class Hash
  def to_query
    reject { |key, value| value.nil? }.map { |args| args.map(&:to_s).map { |text| CGI.escape text }.join ?= }.join ?&
  end
end

def show_hierarchy(values, nn = values.transpose.length, n = nn)
  if n == 1
    values.each do |value, *nothing|
      puts "   " * (nn - n) + (value.nil? || value.to_s.strip.empty? ? value.inspect : value.to_s)
    end
  else
    values.group_by(&:first).each do |value, values|
      puts "   " * (nn - n) + (value.nil? || value.to_s.strip.empty? ? value.inspect : value.to_s)
      show_hierarchy values.map { |value, *args| args }, nn, n-1
    end
  end
end

def show_arcgis(url, *args, dynamic, where)
  open "#{url}?f=json", "Referer" => url do |json|
    response = JSON.parse(json.read)
    case url
    when /\d+$/ # inspect layer
      puts "%s (%s)" % response.values_at("name", "geometryType")
      response["fields"].each do |field|
        puts "  %25s (type: %s, alias: %s)" % field.values_at("name", "type", "alias")
      end
    else # inspect service
      indent = {}
      response["layers"].map do |layer|
        layer.values_at *%w[id parentLayerId name]
      end.each do |id, parent, name|
        indent[id] = parent == -1 ? 0 : 2 + indent[parent]
      end.each do |id, parent, name|
        puts "%4d:#{?\s * indent[id]} %s" % [ id, name ]
      end
    end
  end and return unless args.any?
  query = {
    "f" => "json",
    "where" => where,
    "classificationDef" => {
      "type" => "uniqueValueDef",
      "uniqueValueFields" => [ *args ],
      "fieldDelimiter" => ?|,
    }.to_json
  }
  if dynamic
    layer = {
      "source" => {
        "type" => "mapLayer",
        "mapLayerId" => url[/\d+$/]
      },
      "definitionExpression" => query.delete("where")
    }
    url = url.sub /\d+$/, "dynamicLayer"
    query.merge! "layer" => layer.to_json
  end
  open "#{url}/generateRenderer?#{query.to_query}", "Referer" => url do |json|
    response = JSON.parse(json.read)
    abort [ response["error"]["message"], *response["error"]["details"] ].join(?\n) if response["error"]
    values = response["uniqueValueInfos"].map do |info|
      info["value"].split(?|).map do |value|
        value && value =~ /\s*[\n\r]+|\s+$/ ? value.inspect : value
      end
    end.sort
    show_hierarchy(values)
  end
end

def show_wfs(url, name, field, *fields, values, filter)
  uri = URI.parse url
  query = {
    "service" => "wfs",
    "version" => "2.0.0",
    "request" => "GetFeature",
    "typeNames" => name,
    "count" => 1,
    "startIndex" => 0,
    "outputFormat" => "application/json",
  }
  
  filters = []
  loop do
    cql_filter = [ *filter, *filters ].join " AND "
    cql_filter.empty? ? query.delete("cql_filter") : query.merge!("cql_filter" => cql_filter)
    uri.query = query.to_query
    post = Net::HTTP::Get.new(uri.request_uri)
    use_ssl = uri.scheme == "https"
    json = Net::HTTP.start(uri.host, uri.port, :use_ssl => use_ssl, :read_timeout => 600) { |http| http.request(post).body }
    feature = JSON.parse(json)["features"][0]
    break unless feature

    value = feature["properties"][field]
    filters << case value
    when nil    then "(#{field} IS NOT NULL)"
    when String then "(#{field} NOT IN ('#{value}'))"
    else             "(#{field} NOT IN (#{value}))"
    end
    
    value_filter = case value
    when nil    then "(#{field} IS NULL)"
    when String then "(#{field} IN ('#{value}'))"
    else             "(#{field} IN (#{value}))"
    end
    
    puts "%s%s" % [ "   " * values.length, value || "(null)" ]
    if fields.any?
      show_wfs(url, name, *fields, [ *values, value ], [ *filter, value_filter ].join(" AND "))
    end
  end
end

def show_shapefile(path, layer, *attributes, values, where)
  where = %Q[WHERE #{where}] if where
  attribute_list = attributes.map { |attribute| %Q['#{layer}'.'#{attribute}']}.join ?,
  sql = %Q[SELECT #{attribute_list}, COUNT(*) AS count FROM '#{layer}' #{where} GROUP BY #{attribute_list} ORDER BY #{attribute_list}]
  json = %x[ogr2ogr -f GeoJSON -dialect sqlite -sql "#{sql}" /vsistdout/ "#{path}"]
  rows = JSON.parse(json)["features"].map do |feature|
    OpenStruct.new feature["properties"]
  end
  show = lambda do |rows, (attribute, *attributes), indent = 0|
    rows.group_by(&attribute.to_sym).each do |value, rows|
      count = rows.map(&:count).inject(&:+)
      puts "%8d: %s%s" % [ count, ?\s * indent, value || "(NULL)" ]
      show.(rows, attributes, indent + 2)
    end if attribute
  end
  show.(rows, attributes)
end

dynamic = ARGV.delete "-dynamic"
where = ARGV.each_cons(2).find.with_index do |(flag, argument), index|
  ARGV.slice! index, 2 if flag == "-where"
end&.last

case
when ARGV[0] =~ /\/services\/.*\/MapServer/ then show_arcgis(*ARGV, dynamic, where)
when ARGV[0] =~ /wfs/i then show_wfs(*ARGV, [], where && "(#{where})")
when ARGV[2] then show_shapefile(*ARGV, [], where)
else puts %x[ogrinfo -so "#{ARGV[0]}" #{ARGV[1]}]
end
